{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Medical Concept Builder (MedConB)","text":""},{"location":"#contributions","title":"Contributions","text":"Role Contributor Project Management Alexander Vowinkel Backend Development Alexander Vowinkel Frontend Development Rajesh Sharma UX &amp; UI Susanne Feldt Ideation Alexander Hartenstein, Bayer-Team"},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the Medical Concept Builder (MedConB), a pioneering tool designed to simplify the complex process of translating medical knowledge into a machine-readable format for studies utilizing Real World Data (RWD)[^1]. As the landscape of healthcare continuously evolves, the ability to efficiently encode medical transactions collected in hospitals and clinics becomes increasingly crucial. MedConB stands at the forefront of this initiative, empowering medical professionals and researchers to create reliable and high-quality studies with ease.</p> <p>[^1]: Real World Data refers to the information collected during routine medical care, encompassing every transaction that takes place within clinical settings. This data is recorded using various coding ontologies, such as ICD-9, ICD-10, CPRD, SNOMED, and NDC.</p>"},{"location":"#medical-concepts","title":"Medical Concepts","text":"<p>A medical concept generally refers to an idea, definition, or understanding related to health, disease, diagnosis, treatment, or biomedical research. These concepts can range from specific diseases (like diabetes or hypertension) to broader ideas such as public health measures, epidemiology, clinical practice guidelines, or health policy.</p> <p>In RWD studies a key challenge is to translate medical concepts from the real world into structured and computable formats that can be effectively analyzed and interpreted. This is a process which involves experts from multiple professions - from clinicians over epidemiologists to data specialists - to work closely together. The outcomes range from lists of medical codes (codelists) that are used as e.g. exclusion criteria to complex concepts (sometimes also referred to as phenotypes, ePhenotypes, or phenotype algorithms) that can consist of multiple codelists and lab value criteria in temporal relationship.</p>"},{"location":"#the-challenge","title":"The Challenge","text":"<p>Constructing accurate medical concepts is a complex endeavor that requires the expertise of medical professionals and can significantly affect the quality and reliability of RWD studies. The traditional methods of developing these concepts are often cumbersome and prone to errors, leading to inconsistencies in research outcomes and wasted resources.</p>"},{"location":"#our-solution-medconb","title":"Our Solution: MedConB","text":"<p>MedConB aims to bridge the gap between medical expertise and machine-readable formats. By providing an intuitive platform, we enable medical experts to easily translate their domain knowledge into structured formats that can be rapidly deployed in studies. Our tool fosters collaboration among clinicians and pharmaco-epidemiologists, allowing them to communicate in a universally understood language.</p> <p>Through efforts such as streamlined knowledge curation interfaces and linked data resources, MedConB facilitates the connection of RWD sources to clinical studies. Looking forward, our vision includes enhancing the link to early research and development drug targets, further enriching the medical research ecosystem.</p>"},{"location":"#join-us","title":"Join Us","text":"<p>We invite you to participate in the ongoing development of the Medical Concept Builder. The application is constantly being extended, your feedback and collaboration are invaluable as we work to refine this tool and expand its capabilities. If you wish to get involved or require access to the preview version, please contact us.</p> <p>Together, let's make strides towards a more efficient, accurate, and collaborative approach to medical concept creation.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Docs are created by mkdocs. For the branch <code>develop</code> they are published under this url: https://Bayer-Group.github.io/medconb/.</p> <p>If you want to see the docs locally (e.g. for a different branch), run <code>mkdocs serve -a localhost:8099</code> and go to http://localhost:8099.</p>"},{"location":"#local-deployment","title":"Local Deployment","text":"<p>For you to check out MedConB quickly, we have a docker compose based setup that gets you started quickly to test the tool. All you need is docker and docker compose</p> <p>Then you can run <code>docker compose up</code> to start everything in the background. Once all services are up, go to http://localhost:3001 and use the dev login (\"Sign in using dev token\")</p>"},{"location":"backend/","title":"Backend Architecture Documentation","text":""},{"location":"backend/#overview","title":"Overview","text":"<p>This documentation provides an overview of the backend architecture, focusing on the core concepts, technical implementation, and how different components interact. It is intended for developers working on or with the backend system.</p> <p>The backend is built as a GraphQL API server using Python, following clean architecture principles with clear separation of concerns. The system employs a layered architecture that cleanly separates the API interface, domain logic, and persistence concerns, making it maintainable and testable.</p>"},{"location":"backend/#project-structure","title":"Project Structure","text":"<p>The main application code is organized in the following structure:</p> <pre><code>backend/\n\u251c\u2500\u2500 medconb/            # Main application package\n\u2502   \u251c\u2500\u2500 domain/         # Domain models and business logic\n\u2502   \u251c\u2500\u2500 graphql/        # GraphQL schema implementation\n\u2502   \u251c\u2500\u2500 interactors/    # Use case implementations\n\u2502   \u251c\u2500\u2500 persistence/    # Data persistence layer\n\u2502   \u251c\u2500\u2500 server.py       # Server configuration and setup\n\u2502   \u251c\u2500\u2500 middleware.py   # Request middleware\n\u2502   \u2514\u2500\u2500 types.py        # Common type definitions\n\u251c\u2500\u2500 schema.graphql      # GraphQL schema definition\n</code></pre>"},{"location":"backend/#technical-stack","title":"Technical Stack","text":"<ul> <li>Web Framework: Starlette-based GraphQL server</li> <li>Middleware:<ul> <li>Database session management</li> <li>Authentication</li> <li>Request/response handling</li> </ul> </li> <li>Authentication:<ul> <li>Azure AD for production</li> <li>Development authentication for testing</li> <li>Token-based authentication</li> </ul> </li> <li>Data Access:<ul> <li>SQLAlchemy for database operations</li> <li>Redis for caching</li> </ul> </li> <li>API Layer:<ul> <li>GraphQL with Ariadne</li> <li>Custom type system</li> <li>Interactor pattern for business logic</li> </ul> </li> </ul>"},{"location":"backend/#request-flow","title":"Request Flow","text":"<p>The diagram above shows how requests flow through the system, from the GraphQL API through the various layers to the persistence layer and back.</p>"},{"location":"backend/#api-interface","title":"API Interface","text":"<p>The application exposes a GraphQL API that provides:</p> <ol> <li> <p>Queries:</p> <ul> <li>User-related queries (self, users)</li> <li>Medical coding system ontology queries</li> <li>Code and codelist management</li> <li>Collection management</li> <li>Search functionality for codes and entities</li> <li>Property management</li> </ul> </li> <li> <p>Mutations:</p> <ul> <li>Collection CRUD operations</li> <li>Phenotype management</li> <li>Codelist operations</li> <li>Change management (commits, transient changes)</li> <li>User profile updates</li> </ul> </li> </ol>"},{"location":"backend/#domain-model","title":"Domain Model","text":""},{"location":"backend/#core-entities","title":"Core Entities","text":"<ol> <li> <p>Containers</p> <ul> <li>Organizational structures specifically designed to group and structure Phenotypes and Codelists</li> <li>Support hierarchical organization</li> <li>Can be shared between users</li> <li>Types: Phenotype Collections and Codelist Collections</li> </ul> </li> <li> <p>Users</p> <ul> <li>Represent individuals using the system</li> <li>Have a unique identity and associated workspace</li> <li>Can own and share collections</li> <li>Track user-specific preferences and progress</li> </ul> </li> <li> <p>Workspaces</p> <ul> <li>Personal environments for organizing collections</li> <li>Each user has exactly one workspace</li> <li>Collections can be:<ul> <li>Ordered according to user preference</li> <li>Shared with other users</li> <li>Personal (private to the user)</li> </ul> </li> <li>Primary organizational unit for accessing collections</li> </ul> </li> <li> <p>Medical Coding Systems (Ontologies)</p> <ul> <li>Standardized medical terminology and coding systems</li> <li>Provide the vocabulary and codes for medical concepts</li> <li>Each ontology has a unique identifier and contains multiple codes</li> </ul> </li> <li> <p>Codelists</p> <ul> <li>Groups of related medical codes from coding systems</li> <li>Version-controlled through commits</li> <li>Components:<ul> <li>Codesets: Sets of codes from specific medical coding systems that are part of a codelist version</li> <li>Changesets: Track additions and removals of codes</li> <li>Commits: Record changes with metadata (author, timestamp, message)</li> </ul> </li> <li>Support transient (uncommitted) changes</li> <li>Track derivation history (references to original codelists when copied)</li> </ul> </li> <li> <p>Phenotypes</p> <ul> <li>Medical condition descriptions</li> <li>Can be organized in collections</li> <li>Have configurable properties</li> <li>Include operational descriptions that reference one or more codelists</li> <li>Codelists in the operational description define the concrete medical codes that represent the phenotype</li> </ul> </li> <li> <p>Properties</p> <ul> <li>Configurable attributes that can be attached to collections and phenotypes</li> <li>Types: Text, Number, Enum, Time, User</li> <li>Can be required or read-only</li> <li>Support both system-defined and custom properties</li> </ul> </li> </ol>"},{"location":"backend/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Version Control</p> <ul> <li>Codelists are version-controlled through commits</li> <li>Changes are tracked as additions and removals of codes</li> <li>Each commit includes author information and timestamp</li> <li>Support for transient changes before committing</li> </ul> </li> <li> <p>Property System</p> <ul> <li>Flexible property system for both collections and phenotypes</li> <li>Support for custom properties</li> <li>Automatic tracking of creation and modification metadata</li> <li>Type validation and constraints</li> </ul> </li> <li> <p>Hierarchical Organization</p> <ul> <li>Collections provide hierarchical structure</li> <li>Support for nested organization of phenotypes and codelists</li> <li>Shared collections for collaboration</li> </ul> </li> </ol>"},{"location":"backend/#graphql-layer-and-use-case-implementation","title":"GraphQL Layer and Use Case Implementation","text":""},{"location":"backend/#architecture-overview","title":"Architecture Overview","text":"<p>The GraphQL layer connects to the application's use cases through a pattern that separates the GraphQL resolvers from the business logic implementation. This separation is achieved through:</p> <ol> <li> <p>Interactors: Classes that implement specific use cases (e.g., CreateCollection, UpdatePhenotype)</p> <ul> <li>Handle business logic</li> <li>Operate on the domain model</li> <li>Independent of the GraphQL layer</li> <li>Can include input validation and error handling</li> </ul> </li> <li> <p>InteractorResolver: A bridge between GraphQL and use cases</p> <ul> <li>Manages the lifecycle of interactor execution</li> <li>Handles session management</li> <li>Provides access to the authenticated user</li> <li>Converts domain exceptions to GraphQL errors</li> </ul> </li> <li> <p>Custom ObjectType: A type-safe GraphQL object implementation</p> <ul> <li>Extends Ariadne's ObjectType</li> <li>Provides type checking for parent-child relationships</li> <li>Automatically converts between GraphQL and domain types</li> <li>Validates resolver arguments against DTOs</li> </ul> </li> </ol>"},{"location":"backend/#implementation-structure","title":"Implementation Structure","text":"<ol> <li> <p>Field Resolution</p> <ul> <li>GraphQL fields are mapped to specific interactors using InteractorResolver</li> <li>Example for a mutation:     <pre><code>mutation.set_field(\"createCollection\", InteractorResolver(interactors.CreateCollection))\n</code></pre></li> <li>Example for a query:     <pre><code>query.set_field(\"searchCodes\", InteractorResolver(interactors.SearchCodes))\n</code></pre></li> </ul> </li> <li> <p>Type Resolution</p> <ul> <li>Object fields are resolved using interactors when needed</li> <li>Type-safe parent-child relationships are enforced</li> <li>Automatic conversion between GraphQL arguments and DTOs</li> </ul> </li> </ol>"},{"location":"backend/#resolution-flow","title":"Resolution Flow","text":"<ol> <li> <p>Request Processing</p> <ul> <li>GraphQL receives a query or mutation</li> <li>The appropriate resolver is identified</li> <li>InteractorResolver:<ol> <li>Creates a new interactor instance</li> <li>Provides database session and user context</li> <li>Passes any input data (DTO)</li> <li>Executes the use case</li> <li>Commits the transaction</li> <li>Returns the result or handles errors</li> </ol> </li> </ul> </li> <li> <p>Type Safety</p> <ul> <li>ObjectType ensures type compatibility between GraphQL and domain types</li> <li>Validates parent-child relationships in nested resolvers</li> <li>Converts GraphQL arguments to strongly-typed DTOs</li> <li>Provides clear error messages for type mismatches</li> </ul> </li> </ol> <p>This architecture provides several benefits: - Clear separation of concerns - Reusable business logic - Consistent error handling - Automatic transaction management - Strong type safety throughout the resolution chain</p>"},{"location":"backend/#persistence-layer","title":"Persistence Layer","text":"<p>The persistence layer is built on SQLAlchemy and follows a clean architecture approach with clear abstractions:</p> <ol> <li> <p>Repository Pattern</p> <ul> <li>Each domain entity has a corresponding repository interface</li> <li>Repositories are defined as Python Protocols</li> <li>Implementation details are hidden behind these interfaces</li> <li>Example repository interfaces:<ul> <li>UserRepository</li> <li>CollectionRepository</li> <li>PhenotypeRepository</li> <li>CodelistRepository</li> <li>OntologyRepository</li> </ul> </li> </ul> </li> <li> <p>Session Management</p> <ul> <li>Custom SQLAlchemy session implementation</li> <li>Provides convenient access to repositories</li> <li>Handles complex domain relationships (e.g., container-item relationships)</li> <li>Manages transaction boundaries</li> </ul> </li> <li> <p>Caching Layer</p> <ul> <li>Redis-based caching for ontology and code data</li> <li>In-memory caching for property data</li> <li>Implemented through repository decorators</li> <li>Improves performance for frequently accessed data</li> </ul> </li> </ol> <p>This abstraction allows for:</p> <ul> <li>Clear separation between domain and persistence concerns</li> <li>Easy testing through repository interfaces</li> <li>Flexibility to change the underlying storage implementation</li> <li>Efficient data access through caching where needed</li> </ul>"}]}